////////////////////////////////////////////////////////////////////
// Copyright (C) 2012 SafeNet, Inc. All rights reserved.
//
// Dog(R) is a registered trademark of SafeNet, Inc. 
//
//
////////////////////////////////////////////////////////////////////
#include "dog_api_cpp_.h"

////////////////////////////////////////////////////////////////////
//! \struct CDogLock dogcpp_.h
//! \brief Class providing the thread locking interface
//! (platform dependent).
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
// Windows
////////////////////////////////////////////////////////////////////
#if defined (DOG_HL_TARGET_WINDOWS)

////////////////////////////////////////////////////////////////////
// Construction/Destruction
////////////////////////////////////////////////////////////////////

CDogLock::CDogLock()
: m_bInit(false)
{
	__try
	{
		::InitializeCriticalSection(&m_critLock);
		m_bInit = true;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
	}
}

CDogLock::~CDogLock()
{
	if (m_bInit)
	{
		::DeleteCriticalSection(&m_critLock);
		m_bInit = false;
	}
}

////////////////////////////////////////////////////////////////////
// Implementation
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////
bool CDogLock::isInit() const
{
	return m_bInit;
}

////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////
bool CDogLock::lock()
{
	DIAG_ASSERT(m_bInit);

	if (!m_bInit)
		return false;

	__try
	{
		::EnterCriticalSection(&m_critLock);
		return true;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
	}

	return false;
}

////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////
bool CDogLock::unlock()
{
	DIAG_ASSERT(m_bInit);

	if (!m_bInit)
		return false;

	__try
	{
		::LeaveCriticalSection(&m_critLock);
		return true;
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{
	}

	return false;
}


#else

////////////////////////////////////////////////////////////////////
// Construction/Destruction
////////////////////////////////////////////////////////////////////

CDogLock::CDogLock()
: m_bInit(false)
{
	m_bInit = (0 == ::pthread_mutexattr_init(&m_attrRecursive)) &&
		(0 == ::pthread_mutexattr_settype(&m_attrRecursive, 
		PTHREAD_MUTEX_RECURSIVE)) &&
		(0 == ::pthread_mutex_init(&m_mutex, &m_attrRecursive));
}

CDogLock::~CDogLock()
{
	if (m_bInit)
	{
		pthread_mutex_destroy(&m_mutex);
		pthread_mutexattr_destroy(&m_attrRecursive);
	}
}

////////////////////////////////////////////////////////////////////
// Implementation
////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////
bool CDogLock::isInit() const
{
	return m_bInit;
}

////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////
bool CDogLock::lock()
{
	DIAG_ASSERT(m_bInit);
	return m_bInit && (0 == ::pthread_mutex_lock(&m_mutex));
}

////////////////////////////////////////////////////////////////////
//
////////////////////////////////////////////////////////////////////
bool CDogLock::unlock()
{
	DIAG_ASSERT(m_bInit);
	return m_bInit && (0 == ::pthread_mutex_unlock(&m_mutex));
}

#endif // DOG_HL_TARGET_WINDOWS
